"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WeatherService = void 0;
const client_1 = require("@prisma/client");
const axios_1 = __importDefault(require("axios"));
const prisma = new client_1.PrismaClient();
class WeatherService {
    constructor() {
        this.API_DELAY = 1000; // 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å API
        this.AUTO_FETCH_INTERVAL = 30 * 60 * 1000; // 30 ‡∏ô‡∏≤‡∏ó‡∏µ
        this.BATCH_SIZE = 5; // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
        this.MAX_RETRIES = 3; // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ retry
        this.RETRY_DELAY = 2000; // ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡πà‡∏≠‡∏ô retry (milliseconds)
        this.HTTP_TIMEOUT = 10000; // timeout ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö HTTP requests (10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
    }
    /**
     * ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏ö‡∏ö exponential backoff
     * @param attempt ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£ retry
     * @returns ‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏ô‡πà‡∏ß‡∏á (milliseconds)
     */
    calculateBackoffDelay(attempt) {
        return Math.min(this.RETRY_DELAY * Math.pow(2, attempt), 10000);
    }
    /**
     * ‡∏•‡∏≠‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ã‡πâ‡∏≥‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
     * @param operation ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ã‡πâ‡∏≥
     * @param maxRetries ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
     * @param operationName ‡∏ä‡∏∑‡πà‡∏≠‡∏Ç‡∏≠‡∏á operation ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö logging
     * @returns ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Ç‡∏≠‡∏á operation
     */
    async withRetry(operation, maxRetries = this.MAX_RETRIES, operationName = 'operation') {
        let lastError;
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            }
            catch (error) {
                lastError = error;
                if (attempt === maxRetries) {
                    console.error(`‚ùå ${operationName} failed after ${maxRetries + 1} attempts:`, lastError.message);
                    throw lastError;
                }
                const delay = this.calculateBackoffDelay(attempt);
                console.warn(`‚ö†Ô∏è  ${operationName} failed (attempt ${attempt + 1}/${maxRetries + 1}), retrying in ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        throw lastError;
    }
    /**
     * ‡∏™‡∏£‡πâ‡∏≤‡∏á HTTP client ‡∏ó‡∏µ‡πà‡∏°‡∏µ configuration ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
     * @returns Axios instance
     */
    createHttpClient() {
        const config = {
            timeout: this.HTTP_TIMEOUT,
            headers: {
                'User-Agent': 'WeatherApp/1.0',
            },
        };
        const client = axios_1.default.create(config);
        // ‡πÄ‡∏û‡∏¥‡πà‡∏° response interceptor ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö error handling
        client.interceptors.response.use((response) => response, (error) => {
            if (error.code === 'ECONNABORTED') {
                throw new Error('Request timeout');
            }
            if (error.response?.status >= 500) {
                throw new Error(`Server error: ${error.response.status}`);
            }
            if (error.response?.status === 429) {
                throw new Error('Rate limit exceeded');
            }
            throw error;
        });
        return client;
    }
    /**
     * ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÅ‡∏•‡∏∞‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÄ‡∏Å‡πà‡∏≤ (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î)
     * @returns ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏•‡∏ö
     */
    async clearOldWeatherData() {
        try {
            console.log('üóëÔ∏è  Clearing old weather data...');
            const [deletedWeather, deletedAqi] = await Promise.all([
                prisma.weatherData.deleteMany({
                    where: {
                        id_place: null // ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• province
                    }
                }),
                prisma.aqiData.deleteMany({
                    where: {
                        id_place: null // ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• province
                    }
                })
            ]);
            console.log(`üóëÔ∏è  Deleted ${deletedWeather.count} weather records`);
            console.log(`üóëÔ∏è  Deleted ${deletedAqi.count} AQI records`);
            return {
                deletedWeather: deletedWeather.count,
                deletedAqi: deletedAqi.count
            };
        }
        catch (error) {
            console.error('‚ùå Error clearing old weather data:', error);
            throw error;
        }
    }
    /**
     * ‡∏î‡∏∂‡∏á‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÅ‡∏ö‡∏ö batch processing)
     * @param clearOldData ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
     * @returns ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
     */
    async fetchAndStoreWeatherData(clearOldData = false) {
        const startTime = Date.now();
        const stats = {
            total: 0,
            successful: 0,
            failed: 0,
            duration: 0,
            errors: []
        };
        try {
            // ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
            if (clearOldData) {
                await this.clearOldWeatherData();
            }
            // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ coordinates
            const allProvinces = await prisma.msProvince.findMany();
            const provinces = allProvinces.filter(province => province.latitude !== null &&
                province.longitude !== null);
            stats.total = provinces.length;
            console.log(`üìç Found ${provinces.length} provinces with coordinates`);
            // ‡πÅ‡∏ö‡πà‡∏á‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î‡πÄ‡∏õ‡πá‡∏ô batch
            const batches = this.chunkArray(provinces, this.BATCH_SIZE);
            console.log(`üîÑ Processing ${batches.length} batches of ${this.BATCH_SIZE} provinces each`);
            // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏ï‡πà‡∏•‡∏∞ batch
            for (let i = 0; i < batches.length; i++) {
                const batch = batches[i];
                console.log(`üì¶ Processing batch ${i + 1}/${batches.length} (${batch.length} provinces)`);
                // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î‡πÉ‡∏ô batch ‡∏ô‡∏µ‡πâ‡πÅ‡∏ö‡∏ö parallel
                const batchPromises = batch.map(province => this.processProvinceWithErrorHandling(province));
                const batchResults = await Promise.allSettled(batchPromises);
                // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
                batchResults.forEach((result, index) => {
                    if (result.status === 'fulfilled' && result.value.success) {
                        stats.successful++;
                    }
                    else {
                        stats.failed++;
                        const error = result.status === 'rejected'
                            ? result.reason.message
                            : result.value.error;
                        stats.errors.push(`${batch[index].name}: ${error}`);
                    }
                });
                // ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á batch ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á rate limiting
                if (i < batches.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, this.API_DELAY));
                }
            }
            stats.duration = Date.now() - startTime;
            console.log(`üéâ Batch processing completed:`);
            console.log(`   ‚úÖ Successful: ${stats.successful}/${stats.total}`);
            console.log(`   ‚ùå Failed: ${stats.failed}/${stats.total}`);
            console.log(`   ‚è±Ô∏è  Duration: ${(stats.duration / 1000).toFixed(2)}s`);
            if (stats.errors.length > 0) {
                console.log(`‚ö†Ô∏è  Errors encountered:`);
                stats.errors.slice(0, 5).forEach(error => console.log(`   ‚Ä¢ ${error}`));
                if (stats.errors.length > 5) {
                    console.log(`   ... and ${stats.errors.length - 5} more errors`);
                }
            }
            return stats;
        }
        catch (error) {
            stats.duration = Date.now() - startTime;
            console.error('‚ùå Error in batch processing:', error);
            throw error;
        }
    }
    /**
     * ‡πÅ‡∏ö‡πà‡∏á array ‡πÄ‡∏õ‡πá‡∏ô chunks
     * @param array array ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡πà‡∏á
     * @param size ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ chunk
     * @returns array ‡∏Ç‡∏≠‡∏á chunks
     */
    chunkArray(array, size) {
        const chunks = [];
        for (let i = 0; i < array.length; i += size) {
            chunks.push(array.slice(i, i + size));
        }
        return chunks;
    }
    /**
     * ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏û‡∏£‡πâ‡∏≠‡∏° error handling
     * @param province ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î
     * @returns ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
     */
    async processProvinceWithErrorHandling(province) {
        try {
            await this.processProvince(province);
            return {
                success: true,
                province: province.name
            };
        }
        catch (error) {
            return {
                success: false,
                province: province.name,
                error: error.message
            };
        }
    }
    /**
     * ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß (‡∏î‡∏∂‡∏á‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•)
     * @param province ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î
     */
    async processProvince(province) {
        const lat = Number(province.latitude);
        const lon = Number(province.longitude);
        console.log(`üå§Ô∏è  Processing ${province.name}...`);
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÅ‡∏•‡∏∞‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
        const [weatherData, aqiData] = await Promise.all([
            this.withRetry(() => this.fetchWeatherData(lat, lon), this.MAX_RETRIES, `Weather data for ${province.name}`),
            this.withRetry(() => this.fetchAqiData(lat, lon), this.MAX_RETRIES, `AQI data for ${province.name}`)
        ]);
        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô database transaction
        await this.saveProvinceDataInTransaction(province, weatherData, aqiData);
        console.log(`‚úÖ Completed processing ${province.name}`);
    }
    /**
     * ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î‡πÉ‡∏ô database transaction
     * @param province ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î
     * @param weatherData ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®
     * @param aqiData ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®
     */
    async saveProvinceDataInTransaction(province, weatherData, aqiData) {
        await prisma.$transaction(async (tx) => {
            // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®
            if (weatherData) {
                await tx.weatherData.create({
                    data: {
                        id_province: province.id_province,
                        weather_code: weatherData.current.weather_code,
                        temperature_2m: weatherData.current.temperature_2m,
                        rain: weatherData.current.rain,
                        precipitation: weatherData.current.precipitation,
                        apparent_temperature: weatherData.current.apparent_temperature,
                        sunrise: weatherData.daily.sunrise[0],
                        sunset: weatherData.daily.sunset[0],
                        uv_index_max: weatherData.daily.uv_index_max[0],
                        rain_sum: weatherData.daily.rain_sum[0],
                        precipitation_probability_max: weatherData.daily.precipitation_probability_max[0],
                        temperature_2m_min: weatherData.daily.temperature_2m_min[0],
                        temperature_2m_max: weatherData.daily.temperature_2m_max[0],
                        wind_speed_10m_max: weatherData.daily.wind_speed_10m_max[0],
                    },
                });
            }
            // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®
            if (aqiData) {
                await tx.aqiData.create({
                    data: {
                        id_province: province.id_province,
                        aqi: aqiData.data.aqi,
                        pm25: aqiData.data.iaqi.pm25?.v || null,
                        pm10: aqiData.data.iaqi.pm10?.v || null,
                        no2: aqiData.data.iaqi.no2?.v || null,
                        so2: aqiData.data.iaqi.so2?.v || null,
                        o3: aqiData.data.iaqi.o3?.v || null,
                        co: aqiData.data.iaqi.co?.v || null,
                    },
                });
            }
        });
    }
    /**
     * ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞
     * @param provinceId ID ‡∏Ç‡∏≠‡∏á‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î
     * @returns ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
     */
    async fetchWeatherForProvince(provinceId) {
        try {
            const province = await prisma.msProvince.findUnique({
                where: { id_province: provinceId }
            });
            if (!province) {
                throw new Error(`Province with ID ${provinceId} not found`);
            }
            if (!province.latitude || !province.longitude) {
                throw new Error(`Province ${province.name} has no coordinates`);
            }
            console.log(`üå§Ô∏è  Fetching weather for ${province.name}...`);
            // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®
            const weatherData = await this.fetchWeatherData(Number(province.latitude), Number(province.longitude));
            // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®
            const aqiData = await this.fetchAqiData(Number(province.latitude), Number(province.longitude));
            // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
            const results = { weather: null, aqi: null };
            if (weatherData) {
                results.weather = await prisma.weatherData.create({
                    data: {
                        id_province: province.id_province,
                        weather_code: weatherData.current.weather_code,
                        temperature_2m: weatherData.current.temperature_2m,
                        rain: weatherData.current.rain,
                        precipitation: weatherData.current.precipitation,
                        apparent_temperature: weatherData.current.apparent_temperature,
                        sunrise: weatherData.daily.sunrise[0],
                        sunset: weatherData.daily.sunset[0],
                        uv_index_max: weatherData.daily.uv_index_max[0],
                        rain_sum: weatherData.daily.rain_sum[0],
                        precipitation_probability_max: weatherData.daily.precipitation_probability_max[0],
                        temperature_2m_min: weatherData.daily.temperature_2m_min[0],
                        temperature_2m_max: weatherData.daily.temperature_2m_max[0],
                        wind_speed_10m_max: weatherData.daily.wind_speed_10m_max[0],
                    },
                });
            }
            if (aqiData) {
                results.aqi = await prisma.aqiData.create({
                    data: {
                        id_province: province.id_province,
                        aqi: aqiData.data.aqi,
                        pm25: aqiData.data.iaqi.pm25?.v || null,
                        pm10: aqiData.data.iaqi.pm10?.v || null,
                        no2: aqiData.data.iaqi.no2?.v || null,
                        so2: aqiData.data.iaqi.so2?.v || null,
                        o3: aqiData.data.iaqi.o3?.v || null,
                        co: aqiData.data.iaqi.co?.v || null,
                    },
                });
            }
            return {
                success: true,
                province: province.name,
                data: results
            };
        }
        catch (error) {
            console.error(`‚ùå Error fetching weather for province:`, error);
            throw error;
        }
    }
    /**
     * ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏à‡∏≤‡∏Å Open-Meteo API
     * @param lat ‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î
     * @param lon ‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î
     * @returns ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®
     */
    async fetchWeatherData(lat, lon) {
        try {
            const httpClient = this.createHttpClient();
            // ‡πÉ‡∏ä‡πâ timezone=auto ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ API ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å timezone ‡∏ï‡∏≤‡∏°‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡πÑ‡∏õ
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=weather_code,temperature_2m,rain,precipitation,apparent_temperature&daily=sunrise,sunset,uv_index_max,rain_sum,precipitation_probability_max,temperature_2m_min,temperature_2m_max,wind_speed_10m_max&timezone=auto`;
            const response = await httpClient.get(url);
            return response.data;
        }
        catch (error) {
            console.error(`Error fetching weather data for coordinates (${lat}, ${lon}):`, error.message);
            return null;
        }
    }
    /**
     * ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏à‡∏≤‡∏Å AQICN API
     * @param lat ‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î
     * @param lon ‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î
     * @returns ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®
     */
    async fetchAqiData(lat, lon) {
        try {
            const aqiToken = process.env.AQICN_API_TOKEN;
            if (!aqiToken) {
                console.warn('‚ö†Ô∏è  AQICN API token is not configured - AQI data will be skipped');
                return null;
            }
            const httpClient = this.createHttpClient();
            const response = await httpClient.get(`https://api.waqi.info/feed/geo:${lat};${lon}/?token=${aqiToken}`);
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö response status ‡∏à‡∏≤‡∏Å API
            const responseData = response.data;
            if (responseData.status !== 'ok') {
                throw new Error(`AQI API returned status: ${responseData.status}`);
            }
            return response.data;
        }
        catch (error) {
            console.error(`Error fetching AQI data for coordinates (${lat}, ${lon}):`, error.message);
            return null;
        }
    }
    /**
     * ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏ó‡∏∏‡∏Å 30 ‡∏ô‡∏≤‡∏ó‡∏µ
     */
    startAutoFetch() {
        console.log('üïí Starting automatic weather data fetching every 30 minutes...');
        this.intervalId = setInterval(async () => {
            const startTime = Date.now();
            console.log('‚è∞ Auto-fetching weather data started...');
            try {
                const stats = await this.fetchAndStoreWeatherData(true);
                const duration = (Date.now() - startTime) / 1000;
                console.log('‚úÖ Auto-fetch completed successfully');
                console.log(`   üìä Statistics: ${stats.successful}/${stats.total} provinces processed`);
                console.log(`   ‚è±Ô∏è  Total duration: ${duration.toFixed(2)}s`);
                // Log warning if success rate is low
                const successRate = (stats.successful / stats.total) * 100;
                if (successRate < 80) {
                    console.warn(`‚ö†Ô∏è  Low success rate: ${successRate.toFixed(1)}%`);
                }
            }
            catch (error) {
                const duration = (Date.now() - startTime) / 1000;
                console.error('‚ùå Auto-fetch failed:', error.message);
                console.error(`   ‚è±Ô∏è  Failed after: ${duration.toFixed(2)}s`);
                // Consider implementing notification system here
                // this.notifySystemFailure(error);
            }
        }, this.AUTO_FETCH_INTERVAL);
        // Run initial fetch
        console.log('üöÄ Running initial data fetch...');
        this.fetchAndStoreWeatherData(true).catch(error => {
            console.error('‚ùå Initial fetch failed:', error);
        });
    }
    /**
     * ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
     */
    stopAutoFetch() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = undefined;
            console.log('üõë Stopped automatic weather data fetching');
        }
    }
    /**
     * ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö
     * @returns ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö
     */
    async getSystemHealth() {
        const health = {
            status: 'healthy',
            services: {
                database: false,
                weatherApi: false,
                aqiApi: false
            },
            lastUpdate: undefined,
            dataAvailability: {
                provinces: 0,
                weatherRecords: 0,
                aqiRecords: 0
            }
        };
        try {
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ database
            const provinceCount = await prisma.msProvince.count();
            health.services.database = true;
            health.dataAvailability.provinces = provinceCount;
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            const [weatherCount, aqiCount, latestWeather] = await Promise.all([
                prisma.weatherData.count(),
                prisma.aqiData.count(),
                prisma.weatherData.findFirst({
                    orderBy: { created_at: 'desc' }
                })
            ]);
            health.dataAvailability.weatherRecords = weatherCount;
            health.dataAvailability.aqiRecords = aqiCount;
            health.lastUpdate = latestWeather?.created_at;
        }
        catch (error) {
            console.error('Database health check failed:', error);
            health.status = 'unhealthy';
        }
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Weather API
        try {
            const testLat = 13.7563; // Bangkok coordinates
            const testLon = 100.5018;
            const weatherResponse = await this.withRetry(() => this.fetchWeatherData(testLat, testLon), 1, // single attempt for health check
            'Weather API health check');
            health.services.weatherApi = weatherResponse !== null;
        }
        catch (error) {
            console.warn('Weather API health check failed:', error.message);
        }
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö AQI API
        try {
            if (process.env.AQICN_API_TOKEN) {
                const testLat = 13.7563;
                const testLon = 100.5018;
                const aqiResponse = await this.withRetry(() => this.fetchAqiData(testLat, testLon), 1, // single attempt for health check
                'AQI API health check');
                health.services.aqiApi = aqiResponse !== null;
            }
            else {
                health.services.aqiApi = false; // No token configured
            }
        }
        catch (error) {
            console.warn('AQI API health check failed:', error.message);
        }
        // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏ß‡∏°
        const serviceCount = Object.values(health.services).filter(Boolean).length;
        if (serviceCount === 0) {
            health.status = 'unhealthy';
        }
        else if (serviceCount < 2) {
            health.status = 'degraded';
        }
        return health;
    }
    /**
     * ‡∏£‡∏±‡∏ö‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏ö‡∏ö
     * @returns ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö
     */
    async getSystemStatistics() {
        const stats = {
            autoFetchRunning: this.intervalId !== undefined,
            dataFreshness: {},
            provinceCoverage: {}
        };
        try {
            // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏î‡πÉ‡∏´‡∏°‡πà
            const [oldestWeather, newestWeather] = await Promise.all([
                prisma.weatherData.findFirst({
                    orderBy: { created_at: 'asc' }
                }),
                prisma.weatherData.findFirst({
                    orderBy: { created_at: 'desc' }
                })
            ]);
            if (oldestWeather && newestWeather) {
                stats.dataFreshness.oldestRecord = oldestWeather.created_at;
                stats.dataFreshness.newestRecord = newestWeather.created_at;
                const now = new Date();
                const avgAge = (now.getTime() - newestWeather.created_at.getTime()) / (1000 * 60 * 60);
                stats.dataFreshness.averageAge = Math.round(avgAge * 100) / 100;
            }
            // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
            const [totalProvinces, provincesWithWeather, provincesWithAqi] = await Promise.all([
                prisma.msProvince.count(),
                prisma.msProvince.count({
                    where: {
                        weather_data: {
                            some: {}
                        }
                    }
                }),
                prisma.msProvince.count({
                    where: {
                        aqi_data: {
                            some: {}
                        }
                    }
                })
            ]);
            stats.provinceCoverage = {
                total: totalProvinces,
                withWeatherData: provincesWithWeather,
                withAqiData: provincesWithAqi,
                coveragePercentage: Math.round((provincesWithWeather / totalProvinces) * 100)
            };
        }
        catch (error) {
            console.error('Error getting system statistics:', error);
        }
        return stats;
    }
}
exports.WeatherService = WeatherService;
